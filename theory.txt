load module

sudo insmod src/proc_mem_info.ko

verify it is loaded
lsmod | grep proc_mem

read proc file
cat /proc/proc_mem_info


make clean
make
sudo rmmod proc_mem_info
sudo insmod src/proc_mem_info.ko
cat /proc/proc_mem_info


sudo dmesg | tail -n 50


the next upgrade is to sort processes by RSS memory, so the largest memory consumers appear first — basically making your /proc/proc_mem_info behave like a mini top command.

Do you want me to implement that next?



Debugging / Improving Tips

Show top N memory users only:

Right now, all user processes are printed. You can sort or filter by RSS to only show, e.g., the 10 largest processes.

Example: store PID + RSS in an array and print top N.

Add process filtering:

Only show certain users, e.g., non-root, or GUI processes.

Could filter by task->uid or task->gid.

Reduce memory overhead in kernel:

For large systems, looping through all tasks can be slow.

Consider storing only summary stats in kernel and printing them in /proc.

Include additional memory stats:

Swap usage: info.totalswap and info.freeswap.

Cached memory: info.bufferram + info.cached.

Debug in Live USB:

Since you can’t use dmesg (permission issues), always check /proc/proc_mem_info.

You can also temporarily allow dmesg with:

sudo dmesg --kernel



memory usage breakdown: free, total, used, buffers.

Shows process RSS (resident set size) in KB.

Aligned /proc output for readability.

Debug info included in /proc, no need for dmesg.

Sort Processes

By PID or memory usage for easier reading.

Filter Processes

Only show processes owned by a certain user or running a certain binary.

Make /proc Output Multi-Page Friendly

Add headers, separators, or seq_printf() formatting improvements.


check secure boot

dmesg | tail -20

What exactly is happening (kernel-level explanation)

Your system booted with UEFI Secure Boot enabled

Kernel entered LOCKDOWN_INTEGRITY mode

In this mode:

insmod

modprobe

kexec

/dev/mem

raw MSR access
are blocked unless cryptographically signed

Even root cannot override this.
This is enforced inside the kernel (LSM).

verify secure boot is enables

mokutil --sb-state


secure boot->

sudo bash -c '
/usr/src/linux-headers-$(uname -r)/scripts/sign-file \
sha256 \
/home/oem/kernel_keys/MOK.key \
/home/oem/kernel_keys/MOK.crt \
/home/oem/kernel_process_03/src/proc_mem_info.ko
'


Verify the module is now signed (VERY IMPORTANT)

modinfo proc_mem_info.ko | grep -i signer


why src
insmod needs the exact path to the .ko file.
So the cleanest way is to be in src/.

module was build on different kernel , how to check->
oem@GeekNation:~/kernel_process_03/src$ uname -r
5.15.0-139-generic
oem@GeekNation:~/kernel_process_03/src$ modinfo proc_mem_info.ko | grep vermagic
vermagic:       6.11.0-17-generic SMP preempt mod_unload modversions 









oem@GeekNation:~/kernel_process_03/src$ modinfo proc_mem_info.ko | grep vermagic
vermagic:       5.15.0-139-generic SMP mod_unload modversions 
oem@GeekNation:~/kernel_process_03/src$ sudo /usr/src/linux-headers-$(uname -r)/scripts/sign-file \
> sha256 \
> /home/oem/kernel_keys/MOK.key \
> /home/oem/kernel_keys/MOK.crt \
> proc_mem_info.ko
oem@GeekNat


Kernel build system is path-sensitive

Running make from the wrong directory breaks builds


Linux kernel requires one Makefile inside the module directory,
you add a second Makefile only for human convenience.

The two Makefiles have different jobs
1️⃣ src/Makefile → Kernel-facing
2️⃣ top-level Makefile → Human-facing

They serve different masters.

top level makefile:-
Calls the kernel Makefile

Adds signing

Adds load/unload

Keeps paths clean

Makes teaching easy

Kernel developers always separate:

Kbuild logic (module directory)

Project orchestration (repo root)
